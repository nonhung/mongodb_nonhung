# JVM

### 1.jvm内存分区

a:程序计数器(记录程序执行位置)

b:Java栈 (Java栈是Java方法执行的内存模型)

c:堆 　Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）堆是被所有线程共享的，在JVM中只有一个堆。

d:方法区  方法区 JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。



#### 2.jvm垃圾回收

 I: 什么是垃圾  判断是否为垃圾 

 a:"引用型算法" 堆中对象是否还有引用指向

 b:"可达算法" 通过一系列的称谓  "GC Roots" 的对象作为起始点从这些节点向下搜索，搜索所有走过的路径链，当一个对象到GC Roots 没有任何引用链项目时，则证明此对象不可用

II:垃圾回收算法

 a:静态对象什么时候变成垃圾

我经常听人说:静态方法随着类的加载而加载,随着类的消失而消失.但是,现在在我看来,这种说法是有问题的. 
因为,静态对象要成为垃圾被回收,要满足三个条件: 
1. 这个类的对象变成了垃圾 
2. 加载这个类的类加载器变成了垃圾 
3. 关于这个对象的class对象也变成了垃圾 
    只有满足这三个条件,静态对象才会变成垃圾被回收,要不然静态对象会一直存在于永久带中.

b:新生代和老年代

 新生代把内存区域分为 "Eden"区域 、survivor0区域、survivor1区域，

c:标记清除算法 标记清楚法分成两步 第一步标记要回收的垃圾对象 第二步清除被标记的垃圾对象（缺点:大量垃圾碎片）

d:复制清除算法(专门用于处理年轻代垃圾的)

复制清除算法的优点:效率高于标记清除算法,活着的对象是整齐排列的,没有内存碎片. 
但是这个方法的缺点也很明显,那就是浪费空间.,毕竟如果按照1:1比例来划分空间的话,那么将会有50%的空间被浪费.不过,在jvm中,年轻代空间并不是按照1:1来划分的,而是按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空,这样的过程也被叫做Minor GC,每进行Minor GC一次,存活着的对象的年龄就会加1,当存活着的对象的年龄到达15岁时,就会被送进年老代. 

当然,当整个当survivor1区不足以存放 eden和survivor0的存活对象时，也会将存活对象直接存放到年老代。若是年老代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收

d:标记清理算法(老年代)

 将活着的对象一个接一个的按顺序排好,然后再清除变成垃圾的对象.这种方法不会造成碎片,也不会造成内存的浪费.但是效率不高.所以,这种方法不适合在年轻代使用,而是在对象生命力很顽强的年老代使用

g:所谓分类算法,就是根据内存的不同,采用不同的垃圾回收方式(上面的1,2,3)进行垃圾回收.

f:方法区的回收
方法去处于永久代中，永久代中的回收主要回收两部分的内容：废弃的常量和无用的类。 

1. 回收常量：回收常量和回收堆对象是相同的，如果一个常量在在常量池中已经存在，如果在系统中没有一个对象引用常量池中的常量的话，那么这个常量就需要被回收。 
2. 回收类：回收类的条件比回收常量的苛刻许多：以下三点为必要不充分条件：

该类所有的实例都已经被回收，也就是说java堆中不存在该类的任何实例

该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

加载该类的ClassLoader已经被回收

#### 3.CMS和G1的区别

#### 4.jvm参数

1.软引用（SoftReference）到底 JVM 内部是怎么处理它的，其实并不是非常明确。那么我们能不能使用什么方法来影响软引用的垃圾收集呢，答案是有的。软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以 M bytes 为单位）。从 Java 1.3.1 开始，提供了 -XX:SoftRefLRUPolicyMSPerMB 参数，我们可以以毫秒（milliseconds）为单位设置，应用场景：网页缓存、图片缓存

# JAVA内功

###### 1、强一致性，弱一致性，最终一致性

- 强一致性：对于更新后的数据，要求后续所有节点的任何操作都要获取最新值的情况；
- 弱一致性：对于更新后的数据，后续节点的数据操作可以是新值，也可以是旧值，通过一段时间后后续节点对数据的操作都是新值；
- 最终一致性：是弱一致性的特殊形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值

###### 2.o(1), o(n), o(logn), o(nlogn)

o(1) hsah算法

o(n)for循环遍历算法

o(n^2)冒泡排序

o(logn)log底数为2 二分查找法 当数据量增加256 耗时增加8倍

o(nlogn) 当数据增加256 耗时增加256*8

###### 3.二叉树//红黑树

二叉树特点：



红黑树特点：

性质1. 节点是红色或黑色。

性质2. 根是黑色。

性质3. 所有叶子都是黑色（叶子是NIL节点）。

性质4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

性质5. 从任一节点到其每个叶子的所有简单路径 都包含相同数目的黑色节点。

插入节点的关键是:

1. 插入新节点总是红色节点
2. 如果插入节点的父节点是黑色, 能维持性质
3. 如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质

删除节点的关键是:

1. 如果删除的是红色节点, 不破坏性质
2. 如果删除的是黑色节点, 那么这个路径上就会少一个黑色节点, 破坏了性质. 故删除算法就是通过重新着色或旋转, 来维持性质

###### 4.HashMap ConcurrentHashMap JDK7 JDK8

HashMap

JDK7:底层数据结构  数组+链表 

JDK8:底层数据结构 数组+链表+红黑树

ConcurrentHashMap 

JDK7:维护了一个Segment数组，Segment这个类继承了重入锁ReentrantLock，并且该类里面维护了一个 HashEntry<K,V>[] table数组，在写操作put，remove，扩容的时候，会对Segment加锁，所以仅仅影响这个Segment，不同的Segment还是可以并发的，所以解决了线程的安全问题，同时又采用了分段锁也提升了并发的效率。

JDK8:新的版本主要使用了Unsafe类的CAS自旋赋值+synchronized同步+LockSupport阻塞等手段实现的高效并发，代码可读性稍差。

 ConcurrentHashMap的JDK8与JDK7版本的并发实现相比，最大的区别在于JDK8的锁粒度更细，理想情况下talbe数组元素的大小就是其支持并发的最大个数，在JDK7里面最大并发个数就是Segment的个数，默认值是16，可以通过构造函数改变一经创建不可更改，这个值就是并发的粒度，每一个segment下面管理一个table数组，加锁的时候其实锁住的是整个segment，这样设计的好处在于数组的扩容是不会影响其他的segment的，简化了并发设计，不足之处在于并发的粒度稍粗，所以在JDK8里面，去掉了分段锁，将锁的级别控制在了更细粒度的table元素级别，也就是说只需要锁住这个链表的head节点，并不会影响其他的table元素的读写，好处在于并发的粒度更细，影响更小，从而并发效率更好，但不足之处在于并发扩容的时候，由于操作的table都是同一个，不像JDK7中分段控制，所以这里需要等扩容完之后，所有的读写操作才能进行，所以扩容的效率就成为了整个并发的一个瓶颈点，好在Doug lea大神对扩容做了优化，本来在一个线程扩容的时候，如果影响了其他线程的数据，那么其他的线程的读写操作都应该阻塞，但Doug lea说你们闲着也是闲着，不如来一起参与扩容任务，这样人多力量大，办完事你们该干啥干啥，别浪费时间，于是在JDK8的源码里面就引入了一个ForwardingNode类，在一个线程发起扩容的时候，就会改变sizeCtl这个值，



###### 5.volatile（`关键字只能保证可见性，顺序性，**不能保证原子性**）

现代计算机中，由于 `CPU` 直接从主内存中读取数据的效率不高，所以都会对应的 `CPU` 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。

[![img](https://camo.githubusercontent.com/f9c7b0fc135f983cc4682576e7b2a3167259101f/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744b6654636c7931666d6f75753366706f6b6a33316165306f736a74312e6a7067)](https://camo.githubusercontent.com/f9c7b0fc135f983cc4682576e7b2a3167259101f/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744b6654636c7931666d6f75753366706f6b6a33316165306f736a74312e6a7067)

如上图所示。

`volatile` 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。

使用 `volatile` 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。

###### 7.IO

​        同步：执行一个操作之后，等待结果，然后才继续执行后续的操作。

​        **异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作**

​        **阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作**

​       **非阻塞：进程给CPU传达任务后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。**

#### 设计模式

1.代理模式(aop)

2.工厂模式(ioc)

3.观察者模式







