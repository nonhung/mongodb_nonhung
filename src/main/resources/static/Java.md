# JVM

### 1.jvm内存分区

a:程序计数器(记录程序执行位置)

b:Java栈 (Java栈是Java方法执行的内存模型)

c:堆 　Java中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）堆是被所有线程共享的，在JVM中只有一个堆。

d:方法区  方法区 JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。



#### 2.jvm垃圾回收

 I: 什么是垃圾  判断是否为垃圾 

 a:"引用型算法" 堆中对象是否还有引用指向

 b:"可达算法" 通过一系列的称谓  "GC Roots" 的对象作为起始点从这些节点向下搜索，搜索所有走过的路径链，当一个对象到GC Roots 没有任何引用链项目时，则证明此对象不可用

II:垃圾回收算法

 a:静态对象什么时候变成垃圾

我经常听人说:静态方法随着类的加载而加载,随着类的消失而消失.但是,现在在我看来,这种说法是有问题的. 
因为,静态对象要成为垃圾被回收,要满足三个条件: 
1. 这个类的对象变成了垃圾 
2. 加载这个类的类加载器变成了垃圾 
3. 关于这个对象的class对象也变成了垃圾 
    只有满足这三个条件,静态对象才会变成垃圾被回收,要不然静态对象会一直存在于永久带中.

b:新生代和老年代

 新生代把内存区域分为 "Eden"区域 、survivor0区域、survivor1区域，

c:标记清除算法 标记清楚法分成两步 第一步标记要回收的垃圾对象 第二步清除被标记的垃圾对象（缺点:大量垃圾碎片）

d:复制清除算法(专门用于处理年轻代垃圾的)

复制清除算法的优点:效率高于标记清除算法,活着的对象是整齐排列的,没有内存碎片. 
但是这个方法的缺点也很明显,那就是浪费空间.,毕竟如果按照1:1比例来划分空间的话,那么将会有50%的空间被浪费.不过,在jvm中,年轻代空间并不是按照1:1来划分的,而是按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空,这样的过程也被叫做Minor GC,每进行Minor GC一次,存活着的对象的年龄就会加1,当存活着的对象的年龄到达15岁时,就会被送进年老代. 

当然,当整个当survivor1区不足以存放 eden和survivor0的存活对象时，也会将存活对象直接存放到年老代。若是年老代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收

d:标记清理算法(老年代)

 将活着的对象一个接一个的按顺序排好,然后再清除变成垃圾的对象.这种方法不会造成碎片,也不会造成内存的浪费.但是效率不高.所以,这种方法不适合在年轻代使用,而是在对象生命力很顽强的年老代使用

g:所谓分类算法,就是根据内存的不同,采用不同的垃圾回收方式(上面的1,2,3)进行垃圾回收.

f:方法区的回收
方法去处于永久代中，永久代中的回收主要回收两部分的内容：废弃的常量和无用的类。 

1. 回收常量：回收常量和回收堆对象是相同的，如果一个常量在在常量池中已经存在，如果在系统中没有一个对象引用常量池中的常量的话，那么这个常量就需要被回收。 
2. 回收类：回收类的条件比回收常量的苛刻许多：以下三点为必要不充分条件：

该类所有的实例都已经被回收，也就是说java堆中不存在该类的任何实例

该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

加载该类的ClassLoader已经被回收

#### 3.CMS和G1的区别

#### 4.jvm参数

1.软引用（SoftReference）到底 JVM 内部是怎么处理它的，其实并不是非常明确。那么我们能不能使用什么方法来影响软引用的垃圾收集呢，答案是有的。软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以 M bytes 为单位）。从 Java 1.3.1 开始，提供了 -XX:SoftRefLRUPolicyMSPerMB 参数，我们可以以毫秒（milliseconds）为单位设置，应用场景：网页缓存、图片缓存

# JAVA内功

###### 1、强一致性，弱一致性，最终一致性

- 强一致性：对于更新后的数据，要求后续所有节点的任何操作都要获取最新值的情况；
- 弱一致性：对于更新后的数据，后续节点的数据操作可以是新值，也可以是旧值，通过一段时间后后续节点对数据的操作都是新值；
- 最终一致性：是弱一致性的特殊形式，存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值

###### 2.o(1), o(n), o(logn), o(nlogn)

o(1) hsah算法

o(n)for循环遍历算法

o(n^2)冒泡排序

o(logn)log底数为2 二分查找法 当数据量增加256 耗时增加8倍

o(nlogn) 当数据增加256 耗时增加256*8

###### 3.二叉树//红黑树

二叉树特点：



红黑树特点：

性质1. 节点是红色或黑色。

性质2. 根是黑色。

性质3. 所有叶子都是黑色（叶子是NIL节点）。

性质4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

性质5. 从任一节点到其每个叶子的所有简单路径 都包含相同数目的黑色节点。

插入节点的关键是:

1. 插入新节点总是红色节点
2. 如果插入节点的父节点是黑色, 能维持性质
3. 如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质

删除节点的关键是:

1. 如果删除的是红色节点, 不破坏性质
2. 如果删除的是黑色节点, 那么这个路径上就会少一个黑色节点, 破坏了性质. 故删除算法就是通过重新着色或旋转, 来维持性质

###### 4.HashMap ConcurrentHashMap JDK7 JDK8

HashMap

JDK7:底层数据结构  数组+链表 

JDK8:底层数据结构 数组+链表+红黑树

ConcurrentHashMap 

JDK7:维护了一个Segment数组，Segment这个类继承了重入锁ReentrantLock，并且该类里面维护了一个 HashEntry<K,V>[] table数组，在写操作put，remove，扩容的时候，会对Segment加锁，所以仅仅影响这个Segment，不同的Segment还是可以并发的，所以解决了线程的安全问题，同时又采用了分段锁也提升了并发的效率。

JDK8:新的版本主要使用了Unsafe类的CAS自旋赋值+synchronized同步+LockSupport阻塞等手段实现的高效并发，代码可读性稍差。

 ConcurrentHashMap的JDK8与JDK7版本的并发实现相比，最大的区别在于JDK8的锁粒度更细，理想情况下talbe数组元素的大小就是其支持并发的最大个数，在JDK7里面最大并发个数就是Segment的个数，默认值是16，可以通过构造函数改变一经创建不可更改，这个值就是并发的粒度，每一个segment下面管理一个table数组，加锁的时候其实锁住的是整个segment，这样设计的好处在于数组的扩容是不会影响其他的segment的，简化了并发设计，不足之处在于并发的粒度稍粗，所以在JDK8里面，去掉了分段锁，将锁的级别控制在了更细粒度的table元素级别，也就是说只需要锁住这个链表的head节点，并不会影响其他的table元素的读写，好处在于并发的粒度更细，影响更小，从而并发效率更好，但不足之处在于并发扩容的时候，由于操作的table都是同一个，不像JDK7中分段控制，所以这里需要等扩容完之后，所有的读写操作才能进行，所以扩容的效率就成为了整个并发的一个瓶颈点，好在Doug lea大神对扩容做了优化，本来在一个线程扩容的时候，如果影响了其他线程的数据，那么其他的线程的读写操作都应该阻塞，但Doug lea说你们闲着也是闲着，不如来一起参与扩容任务，这样人多力量大，办完事你们该干啥干啥，别浪费时间，于是在JDK8的源码里面就引入了一个ForwardingNode类，在一个线程发起扩容的时候，就会改变sizeCtl这个值，



###### 5.volatile（`关键字只能保证可见性，顺序性，**不能保证原子性**）

现代计算机中，由于 `CPU` 直接从主内存中读取数据的效率不高，所以都会对应的 `CPU` 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。

[![img](https://camo.githubusercontent.com/f9c7b0fc135f983cc4682576e7b2a3167259101f/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744b6654636c7931666d6f75753366706f6b6a33316165306f736a74312e6a7067)](https://camo.githubusercontent.com/f9c7b0fc135f983cc4682576e7b2a3167259101f/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744b6654636c7931666d6f75753366706f6b6a33316165306f736a74312e6a7067)

如上图所示。

`volatile` 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。

使用 `volatile` 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。

###### 7.IO

​        同步：执行一个操作之后，等待结果，然后才继续执行后续的操作。

​        **异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作**

​        **阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作**

​       **非阻塞：进程给CPU传达任务后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。**

#### 设计模式

1.代理模式(aop)

2.工厂模式(ioc)

3.观察者模式



# Mysql

####  调优：

1.建立索引

  a:查询尽量避免全表扫描，

  b:首先考虑where、order by 建立索引

  c:应尽量避免在 where 子句中对字段进行 null 值判断,否则将导致引擎放弃使用索引而进行全表扫描，如select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0

d:应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

g:应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20 可以这样查询：

select id from t where num=10	

union all 

select id from t where num=20

h:应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：	
select id from t where num/2=100	
应改为:	
select id from t where num=100*2	

减少 or，in，not in，%xxx%语法的使用。		

```
2.分表技术
3.存储过程（一般不要不用）
4.应用层方面：
采用缓存机制，将常用的数据进行缓存，增加访问速度
分库分表，读写分离，将数据分开读写，提升性能
对mysql配置优化 [配置最大并发数my.ini, 调整缓存大小 ]
mysql服务器硬件升级
```

#### 数据库设计三大方式：

1.每一列都是不可分割的原子数据项(不可重复)

2.要求其他字段都依赖于主键

3.消除传递依赖，方便理解，可以看做是“消除冗余”

#### 数据库系统必须维护事务的以下特性(简称ACID)：

###### ⑴ 原子性（Atomicity）

　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

###### ⑵ 一致性（Consistency）

　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

###### ⑶ 隔离性（Isolation）

　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

　　关于事务的隔离性数据库提供了多种隔离级别。

###### ⑷ 持久性（Durability）

　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。



#### 框架

######  spring：ioc加载过程及实现原理

 初始化三步骤：

1. Resource定位（Bean的定义文件定位）

2. 将Resource定位好的资源载入到BeanDefinition

3. 将BeanDefiniton注册到容器中

   

技术点：工厂模式+反射



###### netty 

官网介绍:

简单来讲，Netty是一个提供了易于使用的API的客户端/服务端框架。Netty并发非常高，一个非阻塞的IO，Netty传输速度也非常快，因为他是0拷贝，什么是零拷贝？NIO中的特性之一就是零拷贝，在Java中，内存分为堆和栈以及字符串常量值等等，如果有一些数据从IO中读取并且放到堆里面，中间会经过一些缓冲区。

具体来讲，如果要从IO中读取数据，分为两个步骤：

(1）从IO流中读取出来放到缓冲区，程序从缓冲区中读取，再放到堆中，此时数据就会被拷贝两次才能到达堆或者堆内存中。如果数据量很大，那么就会造成资源的浪费

(2）Netty其实就是利用NIO中的零拷贝特性，当Netty需要接收数据或者传输数据的时候，就会新开辟一块堆内存，然后数据就直接通过IO读取到了新开辟的堆内存中，这样也就加快了数据传输的速度。



